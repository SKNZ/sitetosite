\documentclass[paper=a4, fontsize=11pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage{fourier} % Adobe Utopia
\usepackage[english]{babel}
\usepackage{amsmath,amsfonts,amsthm}
\usepackage{relsize}
\usepackage{svg}

\usepackage{sectsty}
\allsectionsfont{\normalfont\scshape} 

\usepackage{fancyhdr}
\pagestyle{fancyplain}
\fancyhead{}
\fancyfoot[L]{} 
\fancyfoot[C]{}
\fancyfoot[R]{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\setlength{\headheight}{14.6pt}

\usepackage{stmaryrd}
\usepackage{url}
\usepackage{blindtext}
\usepackage{enumitem}

\hoffset = -40pt
\voffset = -40pt
\textwidth = 500pt
\textheight = 760pt

\author{Floran NARENJI-SHESHKALANI \& Jean-Marcellin TRUONG} 

\begin{document}

Authors: Floran NARENJI-SHESHKALANI (643166) \& Jean-Marcellin TRUONG (643357)

\section{General idea}

The original design is composed of several IOT clients exchanging with a single
server on the same local area network (called IOT LAN further on).
The stated objective is to move that server to the cloud while keeping the
communications secure using a site-to-site VPN\@.
Beyond safety, one of the mail design goals is to make this architecture
scalable in the sense that it would be easy to support other customers (e.g.\
other networks of IOT devices who want to securely contact a cloud server).

From a technical standpoint, the servers in the cloud have their own local area
network (called cloud LAN further on) that is not connected to the internet.

\section{Proof of Concept}

\subsection{Docker}

While the scenario intends for this setup to be used in a corporate environment,
the environment has for obvious reasons to be simulated.
For that purpose, Docker is used. Docker offers a quick and easy way to setup
and script multiple simulated machines.
The main advantage of Docker over traditional virtual machines is ease of
reproducibility on different setups, which is key when doing groupwork.
Moreover, Docker is commonly used for cloud-based setups meaning that, for the
cloud part, our simulation is somewhat similar to a real-world application.
\\

Docker Compose is used on top of Docker. Docker Compose is a tool for managing
container instances: containers and networks are programmatically declared and
the infrastructure as a whole can then be launched using simple commands.

\subsection{IOT device \& server}

The specifications state the limitations of the IOT device but nothing about
it's actual functions.
Therefore, the simplest solution was chosen: a simple bash script runs inside
its own Docker container and simulates the IOT client.
This script uses curl to send a plain-text HTTP GET request containing the
current timestamp to a specified IP address/port.

The server is a simple stateless python script running inside its
own container.
The server receives the data from the client over HTTP, prints it out and
discards it.

Note that, due to a Docker technical limitation (host machine is seen as the
default gateway), the default route of both client and server is manually
overwritten to the correct gateway (the local VPN server).

\subsection{Gateways}

The IOT gateways (one per customer network) each have their own tunnel to the
cloud gateway, which is common to all customers.
The gateways serve as the main routing node of all the LAN networks, and all
traffic goes through them.

They are also set up to only let through traffic that is relevant for each
network (see Section~\ref{firewall} for the firewall rules).

\section{Technical choices}

\subsection{VPN}

Various options were considered for the VPN software, but it finally boiled down
to picking between OpenVPN and Strongswan.
Both softwares were well-suited to the usecases and seemed equally strong and
safe.

First of all, we already had past experience in setting up OpenVPN on our own
dedicated servers.
Then, Strongswan implements IPSec, an industry standard that is quite widespread
on common routing infrastructure.
A client who would like to use its own router could readily configure
it so that it connects to our VPN (such configuration is outside the
scope of this project but is quite standard), which is a good selling point for
the customer and a decrease in cost for the company.

Thus, Strongswan was chosen as it was both a sound choice and a good learning
experience.

\subsubsection{Authentication (initial design)}

\huge \danger{} \normalsize
This part talks only about our initial design from the first design document.
The actual design is detailed in the next part.
\\

For authentication, a public key infrastructure with a root certificate and one
certificate for each of our gateways was the initial choice
Unfortunately, we had not yet managed to get it working by the initial design
deadline and authentication systematically failed, even though we believe all the
certificates were signed adequately.

Consequently, Pre-Shared Key (PSK) authentication was used,
in which the password is stored in clear-text in the Strongswan's configuration
file.
At the time, because of the scenario's simplicity (only two gateways were
simulated), we believed this to be as easily maintained as a
PKI-based authentication solution (more on that later).\\

In terms of security, we believe both solutions to be equivalent in most
regards: if the machine is compromised, then a PSK or a private key can be
extracted in the same manner, and both can then be replaced easily by an admin. 
If the private key is password protected, Strongswan will ask for it on startup,
but the same can also be applied to a PSK\@.
For an ongoing connection, having access to the original mean of authentication
is useless as it is only used for initial authentication and not as a session
key (the configuration used here provides perfect forward secrecy).\\

However, a PKI would still be best for multiple reasons.
First of all, an existing organization is likely to have its own PKI already,
and it would be best to leverage such an existing system instead of ``rolling
one's own'' through a PSK\@.

Then, while the current needs are quite simple and are easily satisfied by a
PSK, future needs might not be: there might be more sites, more clients and
potentially a need for revocation.
Such an evolution in requirements is clearly a usecase in favor the PKI\@: it
provides a tremendous advantage in scalability, maintenance and security.

Additionally, in a configuration with multiple customers, a successful attack
against of the cloud gateway compels a full replacement of all PSKs, whereas it
would suffice to replace a single certificate and key pair when using a PKI\@.
Even safer, a smartcard can be used to hold the private key, in which case it
should be safe against both physical and remote attacks.

Finally, a key provided through a PKI will always be fairly long,
whereas a PSK chosen by sloppy students might only be 7 characters long (where
it should have been a very long random string).

\subsubsection{Authentication (final)}

For the final design, the public-key infrastructure is up and running.
The keys are generated outside of any Docker container (e.g.\ this is the
simulated equivalent of having an offline machine where the private key for the
root certificate is stored).
The Docker containers are preloaded with their key: there's no runtime
mechanism for obtaining the key dynamically through an API or similar.
Indeed, having such an API is a safety risk (bigger attack surface) and lays
mainly outside of our domain of competency (we believe such difficult systems to
be best left to more qualified people, such as VeriSign or Let's encrypt).

Currently, each gateway stores its private key on the local drive, which is
a potential danger in case of a breach.
However, Strongswan supports smartcards which should be used for a real
application.
A smartcard is probably one of the safest ways to get a private key
to the customer's physical site: the smartcards are believed to be physically
tamperproof and would not fall victim to a remote attack.
One could even consider having a smartcard delivered to the client and
configuring the gateway remotely, implying much less time spent and therefore
reduced cost per client.

\subsubsection{Encryption algorithms}

Strongswan accepts 3 paramaters related to communications security.

For encryption, AES256-CBC is used, as it is a well-known standard and provides
included MAC\@.

For integrity, prfsha512, a sha512 hash combined with a pseudorandom
function, is used.

Finally, an elliptic curve Diffie-Hellman with curve25515 is used to
construct a session key.
This provides perfect forward secrecy.

\subsection{Routing}

For each customer network, a separate Docker container runs the back-end server.
Such a setup allows efficient use the resources of the cloud servers: a Docker
container has a very resource footprint and the application is presumed not to
be computationally heavy.

It also avoids systematic use of a reverse proxy: because each container has its
own IP in the cloud LAN, the IOT devices can contact it's target directly.

From a security standpoint, we can ensure using the firewall on the cloud
gateway that communications are only flowing between devices belonging to
the same customer (cf Section~\ref{firewall}).
\\

Note that, should the load become too important for a single server, there are
multiple options (ignoring software optimizations, sorted by order of
preference):
\begin{itemize}
    \item the container could be moved to its own cloud server (instead of
    sharing with other containers)
    \item it could be moved to a more powerful cloud server
    \item a load-balancer could be added in front of a swarm of containers
\end{itemize}

\subsection{Firewall}\label{firewall}

On the cloud gateway, the default policy is to forbid all traffic.
Packets used by the IPSec protocol itself are then allowed on the
internet-facing interface only.

The key rules are the following (there is one for each IOT network):
\\

\texttt{%
    -A FORWARD -p tcp -s \$LAN\_SOURCE/16 -d \$DEST\_SERVER/32 --dport 80 -i
    eth\_internet -o eth\_lan -m conntrack --ctstate NEW,ESTABLISHED -m policy
    --dir in --pol ipsec --reqid tunnel\_id --proto esp -j ACCEPT
}
\\

\texttt{%
    -A FORWARD -p tcp -s \$DEST\_SERVER/32 -d \$LAN\_SOURCE/16 --sport 80 -m
    conntrack --ctstate \\ESTABLISHED -i eth\_lan -o eth\_internet -m policy --dir
    out --pol ipsec --reqid tunnel\_id --proto esp -j ACCEPT
}
\\

The first rule will allow incoming traffic from the IOT LAN and to the
destination server (and only that one server) on the TCP port 80 (HTTP) coming
in from the internet and going towards the cloud LAN if it has travelled
through the correct IPSEC VPN tunnel (reqid parameter).

The second rule is the same but in the other direction.

Furthermore, both rules have statefulness constraints: traffic can only be
initiated from the IOT LAN to the cloud LAN and traffic can only leave the cloud
LAN through an already established connection.
\\

On the LAN gateway, the rules simply check that traffic has proper origin and
destination network and that it is indeed IPSEC traffic.
As safety-related rules are already enforced on the cloud gateway, those rules
are much more lax.
Generally, as the IOT gateways are in the client's hand, they should not be
trusted which explains why the cloud gateway has bigger responsibilities.

Firewall rules in full can be found in \texttt{gw/fw} for the IOT gateways and
\texttt{cloudgw/fw} for the cloud gateway.

\end{document}

